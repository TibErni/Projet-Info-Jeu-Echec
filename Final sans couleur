#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

#define BOARD_SIZE 8 

typedef enum {
    EMPTY,
    PLAYER1,
    PLAYER2,
    PLAYER1_PROMOTED,
    PLAYER2_PROMOTED,
} Piece;

typedef Piece Board[BOARD_SIZE][BOARD_SIZE];

void initialize_board(Board board, Piece player1_promoted, Piece player2_promoted) {
    for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
            if (i == 0) {
                if (j == player1_promoted) {
                    board[i][j] = PLAYER1_PROMOTED;
                } else {
                    board[i][j] = PLAYER1;
                }
            } else if (i == BOARD_SIZE - 1) {
                if (j == player2_promoted) {
                    board[i][j] = PLAYER2_PROMOTED;
                } else {
                    board[i][j] = PLAYER2;
                }
            } else {
                board[i][j] = EMPTY;
            }
        }
    }
}


const char* ANSI_COLORS[] = {
    "\x1b[31m",
    "\x1b[32m",
    "\x1b[33m",
    "\x1b[34m",
    "\x1b[35m",
    "\x1b[36m",
    "\x1b[37m",
    "\x1b[90m"
};
const int NUM_COLORS = sizeof(ANSI_COLORS) / sizeof(ANSI_COLORS[0]);

const char* ANSI_RESET = "\x1b[0m";

int get_color_index(int x, int y) {
    return (x + y) % NUM_COLORS;
}

void print_board(const Board board) {
    for (int x = 0; x < BOARD_SIZE; x++) {
        for (int y = 0; y < BOARD_SIZE; y++) {
            int color_index = get_color_index(x, y);
            printf("%s", ANSI_COLORS[color_index]);

            if (board[x][y] == EMPTY) {
                printf(" . ");
            } else if (board[x][y] == PLAYER1) {
                printf(" ▼ ");
            } else if (board[x][y] == PLAYER2) {
                printf(" ▲ ");
            } else if (board[x][y] == PLAYER1_PROMOTED) { // Pièce promue du Joueur 1
                printf("[▼]");
            } else if (board[x][y] == PLAYER2_PROMOTED) { // Pièce promue du Joueur 2
                printf("[▲]");
            }
            printf("%s", ANSI_RESET);
        }
        printf("\n");
    }
}


bool is_inside_board(int x, int y) {
    return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;
}

bool is_piece_on_path(const Board board, int x_start, int y_start, int x_end, int y_end) {
    int dx = x_end - x_start;
    int dy = y_end - y_start;
    int x_step = (dx != 0) ? (dx > 0 ? 1 : -1) : 0;
    int y_step = (dy != 0) ? (dy > 0 ? 1 : -1) : 0;
    int x, y;

    for (x = x_start + x_step, y = y_start + y_step; x != x_end || y != y_end; x += x_step, y += y_step) {
        if (board[x][y] != EMPTY) {
            return true;
        }
    }

    return false;
}

bool is_valid_move(const Board board, Piece current_player, int x_start, int y_start, int x_end, int y_end) {
    int dx = x_end - x_start;
    int dy = y_end - y_start;
    Piece start_piece = board[x_start][y_start];

    if (!is_inside_board(x_end, y_end)) { //  faux si coup en dehors du terrain de jeu
        return false;
    }

    if (start_piece != current_player && start_piece != current_player + 2 || board[x_end][y_end] != EMPTY) { // faux si la case est déjà occupé ou non vide
        return false;
    }

    if (start_piece == current_player) {
        if (current_player == PLAYER1) { // vérifie que le joueur 1 fais un coup en diagonal correct, ou un coup sur la largeur ou sur la longeur
            if (!((dx == 1 && abs(dy) == dx) || (dx == 1 && dy == 0) || (dx == 0 && abs(dy) == 1))) {
                return false;
            }
        } else if (current_player == PLAYER2) { // vérifie que le joueur 2 fais un coup en diagonal correct, ou un coup sur la largeur ou sur la longeur
            if (!((dx == -1 && abs(dy) == dx) || (dx == -1 && dy == 0) || (dx == 0 && abs(dy) == 1))) {
                return false;
            }
        }
    } else if (start_piece == current_player + 2) {
        if (!(abs(dx) <= 1 && abs(dy) <= 1)) {
            return false;
        }
    }

    if (is_piece_on_path(board, x_start, y_start, x_end, y_end)) {
        return false;
    }

    return true;
}

int move_piece(Board board, Piece player, int x_start, int y_start, int x_end, int y_end) {
    Piece start_piece = board[x_start][y_start];
    Piece end_piece = board[x_end][y_end];

    if (start_piece != player && start_piece != player + 2) {
        return 0;  // La pièce de départ n'appartient pas au joueur actuel
    }

    if (end_piece == player || end_piece == player + 2) {
        return 0;  // La case d'arrivée est occupée par une pièce alliée
    }

    int dx = x_end - x_start;
    int dy = y_end - y_start;

    if (is_piece_on_path(board, x_start, y_start, x_end, y_end)) {
        return 0;  // Il y a une pièce sur le chemin
    }

    // Vérifiez si la pièce est promue et pousse une pièce adverse qui n'est pas promue
    if (start_piece == player + 2 && end_piece == 3 - player && end_piece != player + 4 && end_piece != 3 - player + 2) {
        // Calculer la position à laquelle la pièce repoussée doit se déplacer
        int x_push = x_end + (dx == 0 ? 0 : (dx > 0 ? 1 : -1));
        int y_push = y_end + (dy == 0 ? 0 : (dy > 0 ? 1 : -1));
        
        // Vérifiez si la pièce peut être poussée
        if (is_inside_board(x_push, y_push) && board[x_push][y_push] == EMPTY) {
            board[x_push][y_push] = end_piece;
            board[x_end][y_end] = start_piece;
            board[x_start][y_start] = EMPTY;
            return 1;
        } else {
            return 0; // Mouvement invalide si la pièce ne peut pas être poussée
        }
    }

    if (start_piece == player) {
        // Mouvement d'une pièce normale
        if ((player == PLAYER1 && dx >= 0) || (player == PLAYER2 && dx <= 0)) {
            if (dx == 0 || dy == 0 || abs(dx) == abs(dy)) {
                board[x_end][y_end] = player;
                board[x_start][y_start] = EMPTY;
                return 1;
            }
        }
    } else if (start_piece == player + 2) {
    // La pièce est promue
    if ((player == PLAYER1 && dx >= 0) || (player == PLAYER2 && dx <= 0)) {
        if ((dx == 0 || dy == 0 || abs(dx) == abs(dy)) && abs(dx) <= 5 && abs(dy) <= 5) {
            // Si la pièce de fin est une pièce ennemie promue, la pièce promue ne peut pas la pousser
            if (end_piece == 3 - player + 2) {
                return 0;
            }
            // Déplace la pièce promue normalement
            board[x_end][y_end] = player + 2;
            board[x_start][y_start] = EMPTY;
            return 1;
        }
    }
}


    return 0;  // Le mouvement est invalide
}

bool has_valid_move(const Board board, Piece player) {
    for (int x = 0; x < BOARD_SIZE; x++) {
        for (int y = 0; y < BOARD_SIZE; y++) {
            // Si la pièce appartient au joueur actuel
            if (board[x][y] == player || board[x][y] == player + 2) {
                // Essayez tous les mouvements possibles pour cette pièce
                for (int dx = -1; dx <= 1; dx++) {
                    for (int dy = -1; dy <= 1; dy++) {
                        if (dx == 0 && dy == 0) continue;
                        int x_end = x + dx;
                        int y_end = y + dy;
                        // Si le mouvement est valide, le joueur peut bouger
                        if (is_valid_move(board, player, x, y, x_end, y_end)) {
                            return true;
                        }
                    }
                }
            }
        }
    }
    // Si aucun mouvement valide n'est trouvé, le joueur ne peut pas bouger
    return false;
}


int main() {
    Board board;
    int num_rounds;
    int player1_promoted = -1;
    int player2_promoted = -1;
    int player1_score = 0;
    int player2_score = 0;

    printf("Entrez le nombre de manches à jouer : ");
    scanf("%d", &num_rounds);

    for (int i = 0; i < num_rounds; i++) {
        initialize_board(board, player1_promoted, player2_promoted);
        printf("Début de la manche %d:\n", i + 1);
        print_board(board);

        Piece current_player = PLAYER1;

        while (1) {
            int x_start, y_start, x_end, y_end;
            
            printf("Joueur %d, entrez les coordonnées de départ et d'arrivée (x_start y_start x_end y_end) ou -1 pour quitter: ", current_player); 
            scanf("%d", &x_start); 

            if (x_start == -1) {
                break;
            }

            scanf("%d %d %d", &y_start, &x_end, &y_end);

            if (move_piece(board, current_player, x_start, y_start, x_end, y_end)) {
                printf("Mouvement effectué.\n");
                print_board(board);

                if (current_player == PLAYER1 && x_end == BOARD_SIZE - 1) {
                    printf("Le joueur 1 a atteint le côté opposé du plateau !\n");
                    player1_promoted = y_end;
                    player1_score += (board[x_end][y_end] == PLAYER1_PROMOTED) ? 2 : 1;
                    break;
                } else if (current_player == PLAYER2 && x_end == 0) {
                    printf("Le joueur 2 a atteint le côté opposé du plateau !\n");
                    player2_promoted = y_end;
                    player2_score += (board[x_end][y_end] == PLAYER2_PROMOTED) ? 2 : 1;
                    break;
                }

                current_player = (current_player == PLAYER1) ? PLAYER2 : PLAYER1;
            } else {
                printf("Mouvement invalide. Réessayez.\n");
            }

            if (!has_valid_move(board, PLAYER1) && !has_valid_move(board, PLAYER2)) {
                printf("Aucun mouvement possible pour les deux joueurs. Le dernier joueur ayant bougé remporte la manche !\n");
                if (current_player == PLAYER1) {
                    player1_score += 1;
                } else {
                    player2_score += 1;
                }
                break;
            }
        }
    }

    printf("Le score final est : Joueur 1 - %d, Joueur 2 - %d\n", player1_score, player2_score);
    if (player1_score > player2_score) {
        printf("Le joueur 1 remporte la partie !\n");
    } else if (player2_score > player1_score) {
        printf("Le joueur 2 remporte la partie !\n");
    } else {
        printf("Il y a égalité ! Une manche supplémentaire est nécessaire.\n");
    }

    return 0;
}
