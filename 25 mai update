#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>


#define MAX_INPUT_LENGTH 50


#define BOARD_SIZE 8 

typedef enum {
    EMPTY,
    PLAYER1,
    PLAYER1_PROMOTED,
    PLAYER2,
    PLAYER2_PROMOTED
} Piece;

typedef Piece Board[BOARD_SIZE][BOARD_SIZE];

typedef int BackgroundBoard[BOARD_SIZE][BOARD_SIZE];


typedef struct {
    int num_rounds;
    int player1_promoted;
    int player2_promoted;
    int player1_score;
    int player2_score;
    double player1_total_time;
    double player2_total_time;
    Board board;
    BackgroundBoard background_board;
    int last_color_moved;
} GameState;

GameState saved_game_state;
bool game_saved = false;

void initialize_board(Board board, Piece player1_promoted, Piece player2_promoted) {
    for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
            if (i == 0) {
                if (j == player1_promoted) {
                    board[i][j] = PLAYER1_PROMOTED;
                } else {
                    board[i][j] = PLAYER1;
                }
            } else if (i == BOARD_SIZE - 1) {
                if (j == player2_promoted) {
                    board[i][j] = PLAYER2_PROMOTED;
                } else {
                    board[i][j] = PLAYER2;
                }
            } else {
                board[i][j] = EMPTY;
            }
        }
    }
}


// codes ANSI pour le texte noir et les couleurs d'arrière-plan
const char* ANSI_COLORS[] = {
    "\x1b[30m",       // Noir
    "\x1b[41m",       // Fond Rouge
    "\x1b[42m",       // Fond Vert
    "\x1b[43m",       // Fond Jaune
    "\x1b[44m",       // Fond Bleu
    "\x1b[45m",       // Fond Magenta
    "\x1b[46m",       // Fond Cyan
    "\x1b[47m",       // Fond Blanc
    "\x1b[100m",      // Fond Gris
    "\x1b[101m",      // Fond Rouge Clair
};

const int NUM_COLORS = sizeof(ANSI_COLORS) / sizeof(ANSI_COLORS[0]);
const char* ANSI_RESET = "\x1b[0m";

int get_background_color_index() {
    return (rand() % (NUM_COLORS - 1)) + 1;  // Génère un nombre aléatoire entre 1 et NUM_COLORS - 1
}


void print_background_board(BackgroundBoard background_board) {
    for (int x = 0; x < BOARD_SIZE; x++) {
        for (int y = 0; y < BOARD_SIZE; y++) {
            printf("%d ", background_board[x][y]);
        }
        printf("\n");
    }
}


void print_board(const Board board, const BackgroundBoard background_board) {
    for (int x = 0; x < BOARD_SIZE; x++) {
        for (int y = 0; y < BOARD_SIZE; y++) {
            int background_color_index = background_board[x][y];  // Utilise la couleur stockée dans background_board
            printf("%s%s", ANSI_COLORS[0], ANSI_COLORS[background_color_index]);  // Texte Noir, Fond Coloré

            if (board[x][y] == EMPTY) {
                printf("   ");
            } else if (board[x][y] == PLAYER1) {
                printf(" ▼ ");
            } else if (board[x][y] == PLAYER2) {
                printf(" ▲ ");
            } else if (board[x][y] == PLAYER1_PROMOTED) { // Pièce promue du Joueur 1
                printf("[▼]");
            } else if (board[x][y] == PLAYER2_PROMOTED) { // Pièce promue du Joueur 2
                printf("[▲]");
            }
            printf("%s", ANSI_RESET);
        }
        printf("\n");
    }
}




bool is_inside_board(int x, int y) {
    return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;
}

bool is_piece_on_path(const Board board, int x_start, int y_start, int x_end, int y_end) {
    int dx = x_end - x_start;
    int dy = y_end - y_start;
    int x_step = (dx != 0) ? (dx > 0 ? 1 : -1) : 0;
    int y_step = (dy != 0) ? (dy > 0 ? 1 : -1) : 0;
    int x, y;

    for (x = x_start + x_step, y = y_start + y_step; x != x_end || y != y_end; x += x_step, y += y_step) {
        if (board[x][y] != EMPTY) {
            return true;
        }
    }

    return false;
}

bool is_valid_move(const Board board, BackgroundBoard background_board, Piece current_player, int x_start, int y_start, int x_end, int y_end, int last_color_moved) {
    int dx = x_end - x_start;
    int dy = y_end - y_start;
    Piece start_piece = board[x_start][y_start];

    // Vérifier que le mouvement est dans les limites du tableau
    if (!is_inside_board(x_end, y_end)) { 
        return false; //  faux si coup en dehors du terrain de jeu
    }

    // Vérifier que la pièce déplacée appartient au joueur actuel et que la case de destination est vide
    if (start_piece != current_player && start_piece != current_player + 2 || board[x_end][y_end] != EMPTY) { 
        return false; // faux si la case est déjà occupée ou non vide
    }

    // Si la pièce est une pièce normale
    if (start_piece == current_player) {
        // Autoriser uniquement les mouvements d'une case dans toutes les directions
        if (abs(dx) > 1 || abs(dy) > 1) {
            return false;
        }
    } else if (start_piece == current_player + 2) {  // Si la pièce est une pièce promue
        // Autoriser les mouvements dans toutes les directions
        if (dx == 0 && dy == 0) {
            return false;
        }
    }

    // Vérifier si une pièce se trouve sur le chemin (pour les pièces promues)
    if (is_piece_on_path(board, x_start, y_start, x_end, y_end)) {
        return false;
    }

    // Si ce n'est pas le premier mouvement, vérifier que la couleur de la case correspond à la dernière pièce déplacée
    if (last_color_moved != -1 && background_board[x_start][y_start] != last_color_moved) {
        return false;
    }
        //printf("Checking color match: last_color_moved = %d, start color = %d\n", last_color_moved, background_board[x_start][y_start]);
    if (last_color_moved != -1 && background_board[x_start][y_start] != last_color_moved) {
        //printf("Color match failed\n");
        return false;
    }
  
    return true;
}


int move_piece(Board board, BackgroundBoard background_board, Piece player, int x_start, int y_start, int x_end, int y_end, int* last_color_moved) {
    Piece start_piece = board[x_start][y_start];
    Piece end_piece = board[x_end][y_end];

    if (start_piece != player && start_piece != player + 2) {
        return 0;  // La pièce de départ n'appartient pas au joueur actuel
    }

    if (end_piece == player || end_piece == player + 2) {
        return 0;  // La case d'arrivée est occupée par une pièce alliée
    }

    int dx = x_end - x_start;
    int dy = y_end - y_start;

    if (is_piece_on_path(board, x_start, y_start, x_end, y_end)) {
        return 0;  // Il y a une pièce sur le chemin
    }

    // Vérifiez si la pièce est promue et pousse une pièce adverse qui n'est pas promue
    if (start_piece == player + 2 && end_piece == 3 - player && end_piece != player + 4 && end_piece != 3 - player + 2) {
        // Calculer la position à laquelle la pièce repoussée doit se déplacer
        int x_push = x_end + (dx == 0 ? 0 : (dx > 0 ? 1 : -1));
        int y_push = y_end + (dy == 0 ? 0 : (dy > 0 ? 1 : -1));
        
        // Vérifiez si la pièce peut être poussée
        if (is_inside_board(x_push, y_push) && board[x_push][y_push] == EMPTY) {
            board[x_push][y_push] = end_piece;
            board[x_end][y_end] = start_piece;
            board[x_start][y_start] = EMPTY;
            return 1;
        } else {
            return 0; // Mouvement invalide si la pièce ne peut pas être poussée
        }
    }

    if (start_piece == player) {
        // Mouvement d'une pièce normale
        if ((player == PLAYER1 && dx >= 0) || (player == PLAYER2 && dx <= 0)) {
            if (dx == 0 || dy == 0 || abs(dx) == abs(dy)) {
                board[x_end][y_end] = player;
                board[x_start][y_start] = EMPTY;
                return 1;
            }
        }
    } else if (start_piece == player + 2) {
    // La pièce est promue
    if ((player == PLAYER1 && dx >= 0) || (player == PLAYER2 && dx <= 0)) {
        if ((dx == 0 || dy == 0 || abs(dx) == abs(dy)) && abs(dx) <= 5 && abs(dy) <= 5) {
            // Si la pièce de fin est une pièce ennemie promue, la pièce promue ne peut pas la pousser
            if (end_piece == 3 - player + 2) {
                return 0;
            }
            // Déplace la pièce promue normalement
            board[x_end][y_end] = player + 2;
            board[x_start][y_start] = EMPTY;
             *last_color_moved = background_board[x_end][y_end];
            printf("Last Color Moved: %d\n", *last_color_moved);

    return 1;
}
    }
}


    return 0;  // Le mouvement est invalide
}

bool has_valid_move(const Board board, BackgroundBoard background_board, Piece player, int last_color_moved) {
    for (int x = 0; x < BOARD_SIZE; x++) {
        for (int y = 0; y < BOARD_SIZE; y++) {
            // Si la pièce appartient au joueur actuel
            if (board[x][y] == player || board[x][y] == player + 2) {
                // Essayez tous les mouvements possibles pour cette pièce
                for (int dx = -1; dx <= 1; dx++) {
                    for (int dy = -1; dy <= 1; dy++) {
                        if (dx == 0 && dy == 0) continue;
                        int x_end = x + dx;
                        int y_end = y + dy;
                        // Si le mouvement est valide, le joueur peut bouger
                        if (is_valid_move(board, background_board, player, x, y, x_end, y_end, last_color_moved)) {
                            return true;
                        }
                    }
                }
            }
        }
    }
    // Si aucun mouvement valide n'est trouvé, le joueur ne peut pas bouger
    return false;
}





int main() {
    srand(time(NULL));
    int last_color_moved = -1;  
    Board board;
    BackgroundBoard background_board; 

    for (int x = 0; x < BOARD_SIZE; x++) {
        for (int y = 0; y < BOARD_SIZE; y++) {
            if (x == 0 || x == BOARD_SIZE - 1) {  
                background_board[x][y] = y % NUM_COLORS;  
            } else if (y == 0 || y == BOARD_SIZE - 1) {  
                int color_index = get_background_color_index();
                background_board[x][y] = color_index;
                background_board[BOARD_SIZE - x - 1][y] = color_index;  
            } else {
                background_board[x][y] = get_background_color_index();
            }
        }
    }

    int num_rounds;
    int player1_promoted = -1;
    int player2_promoted = -1;
    int player1_score = 0;
    int player2_score = 0;

    char input[MAX_INPUT_LENGTH];
    int num_read;

    printf("Entrez le nombre de manches à jouer : ");
    fgets(input, sizeof(input), stdin);
    while(sscanf(input, "%d", &num_rounds) != 1 || num_rounds <= 0) {
        printf("Erreur d'entrée. Un nombre entier positif est requis. Essayez encore : ");
        fgets(input, sizeof(input), stdin);
    }

    bool game_over = false;

    time_t start_time, end_time;
    double player1_total_time = 0, player2_total_time = 0;

    for (int i = 0; i < num_rounds && !game_over; i++) {
        initialize_board(board, player1_promoted, player2_promoted);
        printf("Début de la manche %d:\n", i + 1);
        print_board(board, background_board);

        Piece current_player = PLAYER1;

        while (1) {
            int x_start, y_start, x_end, y_end;
        
            printf("Joueur %d, entrez les coordonnées de départ et d'arrivée (x_start y_start x_end y_end) ou -1 pour quitter: ", current_player);
            time_t start_time = time(NULL);  // Commence le chronomètre juste avant l'entrée du joueur
            if (fgets(input, MAX_INPUT_LENGTH, stdin) == NULL || strlen(input) >= MAX_INPUT_LENGTH - 1) {
                printf("Erreur d'entrée. Essayez encore.\n");
                continue;
            }
            time_t end_time = time(NULL);  // Arrête le chronomètre juste après l'entrée du joueur
            num_read = sscanf(input, "%d %d %d %d", &x_start, &y_start, &x_end, &y_end);
            if (num_read != 4) {
                printf("Entrée non valide. Quatre nombres entiers sont requis.\n");
                continue;
            }
        
            double elapsed_time = difftime(end_time, start_time);
            printf("Le joueur %d a pris %.2f secondes pour effectuer ce mouvement.\n", current_player, elapsed_time);
            if (current_player == PLAYER1) {
                player1_total_time += elapsed_time;
            } else {
                player2_total_time += elapsed_time;
            }

            if (move_piece(board, background_board, current_player, x_start, y_start, x_end, y_end, &last_color_moved)) {
                printf("Mouvement effectué.\n");
                print_board(board, background_board);

                if (current_player == PLAYER1 && x_end == BOARD_SIZE - 1) {
                    printf("Le joueur 1 a atteint le côté opposé du plateau !\n");
                    player1_promoted = y_end;
                    player1_score += (board[x_end][y_end] == PLAYER1_PROMOTED) ? 2 : 1;
                    break;
                } else if (current_player == PLAYER2 && x_end == 0) {
                    printf("Le joueur 2 a atteint le côté opposé du plateau !\n");
                    player2_promoted = y_end;
                    player2_score += (board[x_end][y_end] == PLAYER2_PROMOTED) ? 2 : 1;
                    break;
                }

                current_player = (current_player == PLAYER1) ? PLAYER2 : PLAYER1;
            } else {
                printf("Mouvement invalide. Réessayez.\n");
            }

            if (!has_valid_move(board, background_board, PLAYER1, last_color_moved) && !has_valid_move(board, background_board, PLAYER2, last_color_moved)) {
                printf("Aucun mouvement possible pour les deux joueurs. Le dernier joueur ayant bougé remporte la manche !\n");
                if (current_player == PLAYER1) {
                    player1_score += 1;
                } else {
                    player2_score += 1;
                }
                break;
            }
        }

        printf("Le score actuel est : Joueur 1 - %d, Joueur 2 - %d\n", player1_score, player2_score);
        printf("Le temps total passé jusqu'à présent est : Joueur 1 - %.2f secondes, Joueur 2 - %.2f secondes\n", player1_total_time, player2_total_time);

        if (i == num_rounds - 1) {  // S'il s'agit de la dernière manche
            if (player1_score > player2_score) {
                printf("Le joueur 1 remporte la partie !\n");
                game_over = true;  // Fin du jeu
            } else if (player2_score > player1_score) {
                printf("Le joueur 2 remporte la partie !\n");
                game_over = true;  // Fin du jeu
            } else {  // En cas d'égalité
                printf("Il y a égalité ! Une manche supplémentaire est nécessaire.\n");
                num_rounds++;  // Ajouter une manche supplémentaire
            }
        }
    }

    printf("Le temps total passé pour l'ensemble de la partie est : Joueur 1 - %.2f secondes, Joueur 2 - %.2f secondes\n", player1_total_time, player2_total_time);

    return 0;
}
