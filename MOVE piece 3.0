bool is_valid_move(const Board board, Piece current_player, int x_start,
                   int y_start, int x_end, int y_end) {
  int dx = x_end - x_start;
  int dy = y_end - y_start;
  Piece start_piece = board[x_start][y_start];

  if (!is_inside_board(x_end,
                       y_end)) { //  faux si coup en dehors du terrain de jeu
    return false;
  }

  if (start_piece != current_player && start_piece != current_player + 2 ||
      board[x_end][y_end] !=
          EMPTY) { // faux si la case est déjà occupé ou non vide
    return false;
  }

  if (start_piece == current_player) {
    if (current_player ==
        PLAYER1) { // vérifie que le joueur 1 fais un coup en diagonal correct,
                   // ou un coup sur la largeur ou sur la longeur
      if (!((dx == 1 && abs(dy) == dx) || (dx == 1 && dy == 0) ||
            (dx == 0 && abs(dy) == 1))) {
        return false;
      }
    } else if (current_player ==
               PLAYER2) { // vérifie que le joueur 2 fais un coup en diagonal
                          // correct, ou un coup sur la largeur ou sur la
                          // longeur
      if (!((dx == -1 && abs(dy) == dx) || (dx == -1 && dy == 0) ||
            (dx == 0 && abs(dy) == 1))) {
        return false;
      }
    }
  } else if (start_piece == current_player + 2) {
    if (!(abs(dx) <= 1 && abs(dy) <= 1)) {
      return false;
    }
  }

  if (is_piece_on_path(board, x_start, y_start, x_end, y_end)) {
    return false;
  }

  return true;
}

int move_piece(Board board, Piece player, int x_start, int y_start, int x_end,
               int y_end) {
  Piece start_piece = board[x_start][y_start];
  Piece end_piece = board[x_end][y_end];

  if (start_piece != player && start_piece != player + 2) {
    return 0; // La pièce de départ n'appartient pas au joueur actuel
  }

  if (end_piece == player || end_piece == player + 2) {
    return 0; // La case d'arrivée est occupée par une pièce alliée
  }

  int dx = x_end - x_start;
  int dy = y_end - y_start;

  if (is_piece_on_path(board, x_start, y_start, x_end, y_end)) {
    return 0; // Il y a une pièce sur le chemin
  }

  // Vérifiez si la pièce est promue et pousse une pièce adverse qui n'est pas promue
  if (start_piece == player + 2 && end_piece == 3 - player &&
      end_piece != player + 4 && end_piece != 3 - player + 2) {
    // Calculer la position à laquelle la pièce repoussée doit se déplacer
    int x_push = x_end + (dx == 0 ? 0 : (dx > 0 ? 1 : -1));
    int y_push = y_end + (dy == 0 ? 0 : (dy > 0 ? 1 : -1));

    // Vérifiez si la pièce peut être poussée et si le mouvement est dans la bonne direction
    if (is_inside_board(x_push, y_push) && board[x_push][y_push] == EMPTY) {
      // Check if the move is not backwards
      if ((player == PLAYER1 && dx >= 0) || (player == PLAYER2 && dx <= 0)) {
        board[x_push][y_push] = end_piece;
        board[x_end][y_end] = start_piece;
        board[x_start][y_start] = EMPTY;
        return 1;
      }
    }
    return 0; // Mouvement invalide si la pièce ne peut pas être poussée ou si le mouvement est dans la mauvaise direction
  }

  if (start_piece == player) {
    // Mouvement d'une pièce normale
    if ((player == PLAYER1 && dx >= 0) || (player == PLAYER2 && dx <= 0)) {
      if (dx == 0 || dy == 0 || abs(dx) == abs(dy)) {
        board[x_end][y_end] = player;
        board[x_start][y_start] = EMPTY;
        return 1;
      }
    }
  } else if (start_piece == player + 2) {
    // La pièce est promue
    if ((player == PLAYER1 && dx >= 0) || (player == PLAYER2 && dx <= 0)) {
      if ((dx == 0 || dy == 0 || abs(dx) == abs(dy)) && abs(dx) <= 5 &&
          abs(dy) <= 5) {
        // Si la pièce de fin est une pièce ennemie promue, la pièce promue ne
        // peut pas la pousser
        if (end_piece == 3 - player + 2) {
          return 0;
        } else {
          // Si la pièce de fin est une pièce ennemie non promue, la pièce promue peut la pousser
          if (end_piece == 3 - player) {
            int x_push = x_end + (dx == 0 ? 0 : (dx > 0 ? 1 : -1));
            int y_push = y_end + (dy == 0 ? 0 : (dy > 0 ? 1 : -1));
            if (is_inside_board(x_push, y_push) && board[x_push][y_push] == EMPTY) {
              board[x_push][y_push] = end_piece;
              board[x_end][y_end] = start_piece;
              board[x_start][y_start] = EMPTY;
              return 1;
            }
          }
          else {
            board[x_end][y_end] = start_piece;
            board[x_start][y_start] = EMPTY;
            return 1;
          }
        }
      }
    }
  }
  return 0; // Si aucun des cas précédents n'est valide, le mouvement est invalide
}
