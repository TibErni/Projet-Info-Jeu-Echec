int move_piece(Board board, Piece player, int x_start, int y_start, int x_end, int y_end) {
  Piece start_piece = board[x_start][y_start];
  Piece end_piece = board[x_end][y_end];

  if (start_piece != player && start_piece != player + 2) {
    return 0; // La pièce de départ n'appartient pas au joueur actuel
  }

  if (!(board[x_end][y_end] == EMPTY || (start_piece == player + 2 && end_piece == 3 - player && end_piece != player + 4 && end_piece != 3 - player + 2))) {
    return 0; // faux si la case est déjà occupée ou non vide
  }


  int dx = x_end - x_start;
  int dy = y_end - y_start;

  if (start_piece == player && is_piece_on_path(board, x_start, y_start, x_end, y_end)) {
    return 0; // Il y a une pièce sur le chemin pour les pions non promus
  }

  // Vérifiez si la pièce est promue et pousse une pièce adverse qui n'est pas promue
  if (start_piece == player + 2 && end_piece == 3 - player && end_piece != player + 4 && end_piece != 3 - player + 2) {
    // Calculer la position à laquelle la pièce repoussée doit se déplacer
    int x_push = x_end + (dx == 0 ? 0 : (dx > 0 ? 1 : -1));
    int y_push = y_end + (dy == 0 ? 0 : (dy > 0 ? 1 : -1));

    // Vérifiez si la pièce peut être poussée
    if (is_inside_board(x_push, y_push) && board[x_push][y_push] == EMPTY) {
      board[x_push][y_push] = end_piece;
      board[x_end][y_end] = start_piece;
      board[x_start][y_start] = EMPTY;
      return 1;
    } else {
      return 0; // Mouvement invalide si la pièce ne peut pas être poussée
    }
  }

  if (start_piece == player) {
    // Mouvement d'une pièce normale
    if ((player == PLAYER1 && dx >= 0) || (player == PLAYER2 && dx <= 0)) {
      if (dx == 0 || dy == 0 || abs(dx) == abs(dy)) {
        board[x_end][y_end] = player;
        board[x_start][y_start] = EMPTY;
        return 1;
      }
    }
  } else if (start_piece == player + 2) {
    // La pièce est promue
    if ((player == PLAYER1 && dx >= 0) || (player == PLAYER2 && dx <= 0)) {
      if ((dx == 0 || dy == 0 || abs(dx) == abs(dy)) && abs(dx) <= 5 &&
          abs(dy) <= 5) {
        // Si la pièce de fin est une pièce ennemie promue, la pièce promue ne peut pas la pousser
        if (end_piece == 3 - player + 2) {
          return 0;
        }
        // Vérifier si une pièce est sur le chemin de la pièce promue
        if (is_piece_on_path(board, x_start, y_start, x_end, y_end)) {
          return 0;
        }
        // Déplace la pièce promue normalement
        board[x_end][y_end] = player + 2;
        board[x_start][y_start] = EMPTY;
        return 1;
      }
    }
  }

  return 0; // Le mouvement est invalide
}
